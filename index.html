<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game with Screen Scroll</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            -webkit-user-select: none;
            /* Safari */
            -ms-user-select: none;
            /* IE 10 and IE 11 */
            user-select: none;
            /* Standard syntax */
        }

        #gameCanvas {
            background-color: #87CEEB;
        }
    </style>
</head>

<body>
    <audio id="gameAudio" src="icy-remix.mp3"></audio>
    <audio id="gameAudioLower" src="icy-remix-lower-volume.mp3"></audio>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        //----------------------------- 🔻 Constants 🔻 -----------------------------/
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const PI = Math.PI;
        var log = console.log.bind(console);

        // Graphics constants
        const playerImage = new Image();
        playerImage.src = 'MegaMan.png';
        const playerImageReversed = new Image();
        playerImageReversed.src = 'MegaManReversed.png';
        const playerImageYellow = new Image();
        playerImageYellow.src = 'MegaManYellow.png';
        const playerImageReversedYellow = new Image();
        playerImageReversedYellow.src = 'MegaManReversedYellow.png';
        const platformsImage = new Image();
        platformsImage.src = 'platforms.png';
        const enemiesImage = new Image();
        enemiesImage.src = 'enemies.png';
        const enemiesImageReversed = new Image();
        enemiesImageReversed.src = 'enemiesReversed.png';
        const starImage = new Image();
        starImage.src = 'star.png';

        // Player sprite
        const playerStates = { idleRight: 0, jumpRight: 1, runRight: 2, fallRight: 3, idleLeft: 4, jumpLeft: 5, runLeft: 6, fallLeft: 7 };
        let currentPlayerState = playerStates.idleRight;
        const playerAnimations = [
            {
                name: 'idleRight',
                playerAnimationDelayer: 20,
                data: [
                    { x: 60 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 95 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 130 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 166 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 201 - (33 - 27), y: 353, width: 33, height: 34 }
                ]
            },
            {
                name: 'jumpRight',
                playerAnimationDelayer: 200,
                data: [
                    // { x: 484 - (33 - 21), y: 428, width: 33, height: 38 },
                    { x: 517 - (33 - 32), y: 426, width: 33, height: 40 }
                    // { x: 556 - (33 - 34), y: 431, width: 33, height: 38 },
                    // { x: 599 - (33 - 27), y: 433, width: 33, height: 33 }
                ]
            },
            {
                name: 'runRight',
                playerAnimationDelayer: 13,
                data: [
                    { x: 54, y: 426, width: 33, height: 35 },
                    { x: 105 - (33 - 25), y: 427, width: 33, height: 34 },
                    { x: 146 - (33 - 17), y: 426, width: 33, height: 35 },
                    { x: 178 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 221 - (33 - 29), y: 427, width: 33, height: 33 },
                    { x: 266, y: 426, width: 33, height: 35 },
                    { x: 314 - (33 - 25), y: 427, width: 33, height: 34 },
                    { x: 356 - (33 - 17), y: 426, width: 33, height: 35 },
                    { x: 390 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 429 - (33 - 29), y: 427, width: 33, height: 33 }

                ]
            },
            {
                name: 'fallRight',
                playerAnimationDelayer: 200,
                data: [
                    // { x: 484 - (33 - 21), y: 428, width: 33, height: 38 },
                    { x: 556 - (33 - 34), y: 431, width: 33, height: 38 }
                    // { x: 556 - (33 - 34), y: 431, width: 33, height: 38 },
                    // { x: 599 - (33 - 27), y: 433, width: 33, height: 33 }
                ]
            },
            {
                name: 'idleLeft',
                playerAnimationDelayer: 20,
                data: [
                    { x: 915 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 880 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 845 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 809 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 775 - (33 - 27), y: 353, width: 33, height: 34 }
                ]
            },
            {
                name: 'jumpLeft',
                playerAnimationDelayer: 200,
                data: [
                    { x: 453 - (33 - 32), y: 426, width: 33, height: 40 }
                ]
            },
            {
                name: 'runLeft',
                playerAnimationDelayer: 13,
                data: [
                    { x: 915, y: 426, width: 33, height: 35 },
                    { x: 880 - (33 - 25), y: 427, width: 33, height: 34 },

                    { x: 853 - (33 - 17), y: 426, width: 33, height: 35 },

                    { x: 805 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 755 - (33 - 29), y: 427, width: 33, height: 33 },
                    { x: 703, y: 426, width: 33, height: 35 },
                    { x: 670 - (33 - 25), y: 427, width: 33, height: 34 },

                    { x: 643 - (33 - 17), y: 426, width: 33, height: 35 },

                    { x: 591 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 548 - (33 - 29), y: 427, width: 33, height: 33 }

                ]
            },
            {
                name: 'fallLeft',
                playerAnimationDelayer: 200,
                data: [
                    { x: 412 - (33 - 34), y: 431, width: 33, height: 38 }
                ]
            },
        ];
        let playerAnimationProgress = 0;

        // Platforms sprite
        /*
            dimensions of a single platform:
            4628
            665

            positions:
            0: 21-30
            791: 31-40
            1577: 41-50
            2355: 91-100
            3164: 71-80
            4020: 11-20
            5094: 81-90
            skip
            7022: 0-10
            skip
            9032: 61-70
            10033: 51-60
        */
        const platformAnimation = [7022, 4020, 0, 791, 1577, 10033, 9032, 3164, 5094, 2355];

        //Math.floor(gameFrame / enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].enemyAnimationDelayer) % enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].data.length;
        // Enemies sprite
        const enemyAnimation = [
            [ // enemy type 1
                {
                    enemyType: 1,
                    enemyAnimationDelayer: 20,
                    data: [
                        { x: 310, y: 15, width: 19, height: 19 },
                        { x: 290, y: 15, width: 18, height: 19 },
                        { x: 267 - (18 - 21), y: 15, width: 18, height: 19 },
                        { x: 247, y: 15, width: 18, height: 19 },
                        { x: 227, y: 16, width: 18, height: 18 },
                        { x: 207, y: 13, width: 18, height: 21 },
                        { x: 187, y: 19, width: 18, height: 15 },
                        { x: 167, y: 23, width: 18, height: 11 },
                        { x: 167, y: 23, width: 18, height: 11 },
                        { x: 167, y: 23, width: 18, height: 11 },
                        { x: 167, y: 23, width: 18, height: 11 },
                        { x: 167, y: 23, width: 18, height: 11 }
                    ]
                },
                {},
                {
                    enemyType: 1,
                    enemyAnimationDelayer: 20,
                    data: [
                        { x: 2, y: 15, width: 19, height: 19 },
                        { x: 23, y: 15, width: 18, height: 19 },
                        { x: 40 - (18 - 21), y: 15, width: 18, height: 19 },
                        { x: 66, y: 15, width: 18, height: 19 },
                        { x: 86, y: 16, width: 18, height: 18 },
                        { x: 106, y: 13, width: 18, height: 21 },
                        { x: 126, y: 19, width: 18, height: 15 },
                        { x: 146, y: 23, width: 18, height: 11 },
                        { x: 146, y: 23, width: 18, height: 11 },
                        { x: 146, y: 23, width: 18, height: 11 },
                        { x: 146, y: 23, width: 18, height: 11 },
                        { x: 146, y: 23, width: 18, height: 11 }
                    ]
                }
            ],
            [ // enemy type 2
                {
                    enemyType: 2,
                    enemyAnimationDelayer: 10,
                    data: [
                        { x: 143, y: 87, width: 18, height: 18 },
                        { x: 123, y: 86, width: 18, height: 19 },
                        { x: 103, y: 85, width: 18, height: 20 },
                        { x: 83, y: 86, width: 18, height: 19 },
                        { x: 63, y: 87, width: 18, height: 18 },
                        { x: 43, y: 86, width: 18, height: 19 },
                        { x: 23, y: 85, width: 18, height: 20 },
                        { x: 3, y: 86, width: 18, height: 19 }
                    ]
                },
                {},
                {
                    enemyType: 2,
                    enemyAnimationDelayer: 10,
                    data: [
                        { x: 170, y: 87, width: 18, height: 18 },
                        { x: 190, y: 86, width: 18, height: 19 },
                        { x: 210, y: 85, width: 18, height: 20 },
                        { x: 230, y: 86, width: 18, height: 19 },
                        { x: 250, y: 87, width: 18, height: 18 },
                        { x: 270, y: 86, width: 18, height: 19 },
                        { x: 290, y: 85, width: 18, height: 20 },
                        { x: 310, y: 86, width: 18, height: 19 }
                    ]
                }
            ]
        ];
        let enemyAnimationProgress = 0;

        // Star sprite
        const starAnimation = {
            playerAnimationDelayer: 20,
            data: [
                { x: 101, y: 10, width: 24, height: 27 },
                { x: 129, y: 10, width: 19, height: 27 },
                { x: 160 - ((24 - 7) / 2), y: 10, width: 24, height: 27 },
                { x: 178, y: 10, width: 19, height: 27 },
                { x: 101, y: 60, width: 24, height: 27 },
                { x: 129, y: 60, width: 19, height: 27 },
                { x: 159 - ((24 - 7) / 2), y: 60, width: 24, height: 27 },
                { x: 178, y: 60, width: 19, height: 27 }
            ]
        };
        //----------------------------- 🔺 Constants 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Resize canvas for mobile 🔻 -----------------------------/
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;

            // Regular expressions for mobile User Agent detection
            return /android/i.test(userAgent) || /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
        }

        function resizeCanvas() {
            if (isMobileDevice()) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        //----------------------------- 🔺 Resize canvas for mobile 🔺 -----------------------------/
        /////////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Game settings 🔻 -----------------------------/
        let gravity = 0;
        if (isMobileDevice()) {
            gravity = 1.75;
        } else {
            gravity = 0.48;
        }
        const friction = 0.95;
        const baseJump = -11; // Base jump velocity
        //----------------------------- 🔺 Game settings 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Player 🔻 -----------------------------/
        const playerWidth = 35;
        const playerHeight = 35;
        const playerStartY = CANVAS_HEIGHT - 100;
        let player = {
            x: (CANVAS_WIDTH / 2) - 10,
            y: playerStartY,
            width: playerWidth,
            height: playerHeight,
            speed: 50, // horizonal max speed
            velX: 0,
            velY: 0,
            jumping: false,
            onPlatform: true,
            lastRunningDirection: 'right',
            stuckOnSide: 1, // 0 = stuck, 1 = not stuck - preperation for future bug fix
            power: false
        };
        //----------------------------- 🔺 Player 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Enemies 🔻 -----------------------------/
        const enemyWidth = 25;
        const enemyHeight = 25;
        const enemyMarginFromSides = 10;
        function createEnemy(type, platform) {
            // calculate random x position for the enemy - but make sure it's within the canvas
            let randomEnemyX = platform.x + Math.random() * (platform.width - enemyWidth);
            if (randomEnemyX < 0) {
                randomEnemyX = enemyMarginFromSides; // margin from the left
            } else if (randomEnemyX + enemyWidth > CANVAS_WIDTH) {
                randomEnemyX = CANVAS_WIDTH - (enemyWidth + enemyMarginFromSides); // margin from the right
            }
            return {
                type,
                x: randomEnemyX, // Random starting position on the platform
                y: platform.y - enemyHeight, // Positioned above the platform
                width: enemyWidth,
                height: enemyHeight,
                speed: type === 2 ? 1 : 0, // Type 2 enemies move
                direction: Math.random() < 0.5 ? 1 : -1 // Direction for moving enemies: 1 = left, -1 = right
            };
        }

        function updateEnemyPosition(enemy, platform) {
            if (enemy.type === 2) {
                enemy.x -= enemy.speed * enemy.direction; // it was += but then the direction (1 and -1) and the enemy sprite to use was not matching

                // Change direction if enemy reaches the edge of the platform
                if (enemy.x <= Math.max(platform.x, 0) || enemy.x + enemy.width >= Math.min(platform.x + platform.width, CANVAS_WIDTH)) {
                    enemy.direction *= -1;
                }
            }
        }

        function checkPlayerEnemyCollision(enemy) {
            return player.x < enemy.x + enemy.width &&
                player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height &&
                player.y + player.height > enemy.y &&
                player.power === false;
        }
        //----------------------------- 🔺 Enemies 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Star 🔻 -----------------------------/
        const starWidth = 25;
        const starHeight = 25;
        const starMarginFromSides = 10;
        let powerTimer = null; // Timer for the power-up duration
        let starPowerTimeLeft = null; // Time left for the power-up
        function createStar(platform) {
            // calculate random x position for the star - but make sure it's within the canvas
            let randomStarX = platform.x + Math.random() * (platform.width - starWidth);
            if (randomStarX < 0) {
                randomStarX = starMarginFromSides; // margin from the left
            } else if (randomStarX + starWidth > CANVAS_WIDTH) {
                randomStarX = CANVAS_WIDTH - (starWidth + starMarginFromSides); // margin from the right
            }

            return {
                x: randomStarX, // Random starting position on the platform
                y: platform.y - starHeight, // Positioned above the platform
                width: starWidth,
                height: starHeight,
                starAnimationProgress: 0
            };
        }
        function checkPlayerStarCollision(star) {
            return player.x < star.x + star.width &&
                player.x + player.width > star.x &&
                player.y < star.y + star.height &&
                player.y + player.height > star.y;
        }

        function collectStar() {
            // If there's an existing power timer, clear it
            if (powerTimer) {
                clearTimeout(powerTimer);
            }

            // Give power to the player
            givePowerToPlayer();

            // Set a new timer for 8 seconds
            powerTimer = setTimeout(removePowerFromPlayer, 8000);
        }

        function givePowerToPlayer() {
            player.power = true;
            starPowerTimeLeft = new Date().getTime() + 8000; // 8 seconds
        }

        function removePowerFromPlayer() {
            player.power = false;
            powerTimer = null;
            starPowerTimeLeft = null;
        }

        //----------------------------- 🔺 Star 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Platforms 🔻 -----------------------------/
        let platforms = [];
        let platformCounter = 0;
        const platformHeight = 20;

        const initialPlatformWidthRange = [200, 350];
        const widthRangeBottomValueDecreaseStep = 10; // The amount by which the range decreases
        const widthRangeTopValueDecreaseStep = 20; // The amount by which the range decreases
        const widthRangeInterval = 20; // Interval after which the range decreases

        let platformWidthRange = [...initialPlatformWidthRange];

        const initialPlatformGap = 75;
        const gapIncreaseStep = 20; // The amount by which the gap increases
        const gapInterval = 10; // Interval after which the gap increases

        let platformGap = initialPlatformGap;


        const enemyOnPlatformRatio = 0.05; // 5% chance of enemy on platform
        const verticalMovingPlatformRatio = 0.06; // 6% chance of vertical moving platform
        const starOnPlatformRatio = 0.05; // 5% chance of star on platform

        // Generate random width for the platform
        function randomWidth() {
            if ((platformCounter - 1) % widthRangeInterval === 0 && platformCounter !== 0 && platformCounter !== 1) {
                platformWidthRange[0] = Math.max(platformWidthRange[0] - widthRangeBottomValueDecreaseStep, 50); // Lower limit to prevent too narrow platforms
                platformWidthRange[1] = Math.max(platformWidthRange[1] - widthRangeTopValueDecreaseStep, platformWidthRange[0]);
            }

            if (platformCounter % 10 === 0) {
                return CANVAS_WIDTH;
            } else {
                return Math.random() * (platformWidthRange[1] - platformWidthRange[0]) + platformWidthRange[0];
            }
        }


        // Generate random x for the platform
        function randomX(platformWidth) {
            if (platformWidth == CANVAS_WIDTH) {
                return 0;
            } else {
                return (Math.random() * CANVAS_WIDTH) - platformWidth / 2;
            }
        }

        // Generate random width AND random x for the platform
        function randomWidthAndX() {
            let width = randomWidth(platformCounter);
            let x = randomX(width);
            return [width, x];
        }

        function chooseIfEnemyOnPlatform(platform) {
            if (Math.random() < enemyOnPlatformRatio && platformCounter > 10 && platformCounter % 10 != 0) {
                const enemyType = Math.random() < 0.5 ? 1 : 2;
                platform.enemy = createEnemy(enemyType, platform);
            }
        }

        function chooseIfVerticalMovingPlatform(platform, index) {
            if (Math.random() < verticalMovingPlatformRatio && platformCounter > 10 && platformCounter % 10 != 0 && !platforms[index - 1].verticalMoving) {
                let relevantPlatformGap = getPlatformGap(platform.number);
                platform.verticalMoving = true;
                platform.verticalSpeed = 0.005; // Speed of vertical movement
                platform.maxVerticalMovement = relevantPlatformGap / 2; // Maximum distance the platform moves vertically

                let offset = Math.random() * relevantPlatformGap - relevantPlatformGap / 2; // Random offset within the gap
                offset = 0;
                platform.y += offset;

                // set currentVerticalMovement based on the offset
                platform.currentVerticalMovement = (offset / (relevantPlatformGap / 2) + 1) * PI / 2;
            }
        }

        function chooseIfStarOnPlatform(platform) {
            if (Math.random() < starOnPlatformRatio && platformCounter > 10 && platformCounter % 10 != 0 && !platform.enemy) {
                platform.star = createStar(platform);
            }
        }

        // Generate the 10 platforms
        for (let i = 0; i < 10; i++) {
            let [tempWidth, tempX] = randomWidthAndX();
            platforms.push({
                x: tempX,
                y: (CANVAS_HEIGHT - 50) - (platformGap * i),
                initialY: (CANVAS_HEIGHT - 50) - (platformGap * i),
                width: tempWidth,
                height: platformHeight,
                number: platformCounter,
                playerStandTime: 0, // time in milliseconds the player has been on the platform
                falling: false, // indicates whether the platform is falling
                fallSpeed: 0, // speed at which the platform falls
                xToDrawFromInSprite: Math.random() * (4628 - tempWidth)
            });

            chooseIfEnemyOnPlatform(platforms[i]);
            chooseIfVerticalMovingPlatform(platforms[i], i);
            chooseIfStarOnPlatform(platforms[i]);

            platformCounter++;
        }

        function repositionPlatform(platform, index) {
            if (platform.y - enemyHeight > CANVAS_HEIGHT) { // If platform falls off-screen, reset it
                updatePlatformGap();
                let [tempWidth, tempX] = randomWidthAndX();
                platform.y = platforms[heighestPlatformIndex].y - platformGap; // Move platform to the top
                platform.initialY = platform.y;
                platform.x = tempX;
                platform.width = tempWidth;
                platform.number = platformCounter; // Increase platform number
                heighestPlatformIndex = index; // Update the heighest platform index
                platform.playerStandTime = 0;
                platform.falling = false;
                platform.fallSpeed = 0;
                platform.xToDrawFromInSprite = Math.random() * (4628 - tempWidth);
                platform.verticalMoving = null;

                chooseIfEnemyOnPlatform(platform);
                chooseIfVerticalMovingPlatform(platform, index);
                chooseIfStarOnPlatform(platform);

                platformCounter++;
            }
        }

        function updateVerticalMovement(platform) {
            if (platform.verticalMoving) {

                platform.currentVerticalMovement += platform.verticalSpeed;

                // Use sine wave for smooth easing transition
                let sineWave = Math.sin(platform.currentVerticalMovement);
                platform.y += sineWave * platform.maxVerticalMovement * platform.verticalSpeed;

                // Move enemy if exists
                if (platform.enemy) {
                    platform.enemy.y += sineWave * platform.maxVerticalMovement * platform.verticalSpeed;
                }

                if (platform.star) {
                    platform.star.y += sineWave * platform.maxVerticalMovement * platform.verticalSpeed;
                }

            }
        }

        function updatePlatformGap() {
            // Check if the current platform number is divisible by the gapInterval (10)
            // and it's not the first platform (number 0)
            // This will update the gap starting from the 11th, 21st, 31st platforms, etc.
            if ((platformCounter - 1) % gapInterval === 0 && platformCounter !== 0 && platformCounter !== 1) {
                platformGap += gapIncreaseStep;
            }
        }

        // function that returns the desired platformGap based on a platform number
        function getPlatformGap(platformNumber) {
            return initialPlatformGap + gapIncreaseStep * Math.floor(Math.abs(platformNumber - 1) / 10);
        }


        //----------------------------- 🔺 Platforms 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Key events 🔻 ------------------------------/
        let keys = [];
        window.addEventListener('keydown', function (e) {
            keys[e.keyCode] = true;
            if (e.keyCode == 32 && !player.jumping && player.onPlatform && !player.velY > 0) { // Space key for jump
                player.jumping = true;
                if (player.velX > 0) {
                    currentPlayerState = playerStates.jumpRight;
                } else {
                    currentPlayerState = playerStates.jumpLeft;
                }
                playerAnimationProgress = 0;
                // player.velY = baseJump - Math.abs(player.velX); // Old "running faster = higher jump" - linear growth
                if ((keys[37] && player.x <= 0) || (keys[39] && player.x + player.width >= CANVAS_WIDTH)) { // If the player jumps after "accelerating" into the wall
                    player.velY = baseJump;
                } else {
                    player.velY = baseJump - Math.pow(Math.abs(player.velX), 2) * 0.2; // New "running faster = higher jump" - exponential growth
                }

                // First spacebar plays the audio
                if (!firstSpacebarPressedForAudio) {
                    firstSpacebarPressedForAudio = true;
                    toggleMute();
                }
            }
        });
        window.addEventListener('keyup', function (e) {
            keys[e.keyCode] = false;
        });
        //------------------------------ 🔺 Key events 🔺 ------------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Touch events for mobile 🔻 ------------------------------/

        // Variables to store touch positions and time
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchX;
        let lastTouchY;
        let lastTouchTime;
        let isSwipeUpDetected = false; // Flag to check if swipe up is already detected

        // Add touch event listeners
        canvas.addEventListener('touchstart', function (e) {
            if (!firstSpacebarPressedForAudio) {
                firstSpacebarPressedForAudio = true;
                toggleMute();
            }
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            lastTouchX = touchStartX;
            lastTouchY = touchStartY;
            lastTouchTime = Date.now(); // Record the start time
            isSwipeUpDetected = false; // Reset swipe up detection
        }, { passive: false });

        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault();
            let touchMoveX = e.touches[0].clientX;
            let touchMoveY = e.touches[0].clientY;
            let currentTime = Date.now();

            let deltaX = touchMoveX - lastTouchX;
            let deltaTime = currentTime - lastTouchTime;

            // Normalize the swipe speed
            let swipeSensitivity = 5; // Adjust for sensitivity - higher = sensitive is stronger
            let maxSwipeSpeed = 2; // Maximum speed per swipe - higher = faster max speed

            if (deltaTime > 0) { // Avoid division by zero
                let swipeSpeed = (deltaX / deltaTime) * swipeSensitivity;
                swipeSpeed = Math.max(Math.min(swipeSpeed, maxSwipeSpeed), -maxSwipeSpeed);
                player.velX += swipeSpeed;
                player.velX = Math.max(Math.min(player.velX, player.speed), -player.speed);
            }

            // Upward swipe detection
            if (!player.jumping && player.onPlatform && lastTouchY - touchMoveY > 10) { // 10 = minimum swipe distance
                player.jumping = true;
                if (player.velX > 0) {
                    currentPlayerState = playerStates.jumpRight;
                } else {
                    currentPlayerState = playerStates.jumpLeft;
                }
                playerAnimationProgress = 0;
                player.velY = baseJump * 1.9 - Math.abs(player.velX) * 0.75;
                isSwipeUpDetected = true;
            }

            lastTouchX = touchMoveX;
            lastTouchY = touchMoveY;
            lastTouchTime = currentTime;
        }, { passive: false });

        canvas.addEventListener('touchend', function (e) {
            e.preventDefault();
            // Reset variables on touch end
            touchStartX = 0;
            touchStartY = 0;
            lastTouchX = 0;
            lastTouchY = 0;
            lastTouchTime = 0;
            player.velX = 0; // Adjust for smoother stopping
            isSwipeUpDetected = false; // Reset swipe up detection
        }, { passive: false });

        //------------------------------ 🔺 Touch events for mobile 🔺 ------------------------------/
        ////////////////////////////////////////////////////////////////////////////////////////
        // ------------------------------ 🔻 Audio & Mute 🔻 ------------------------------/
        let gameAudio = null;
        if (isMobileDevice()) {
            gameAudio = document.getElementById('gameAudioLower');
        } else {
            gameAudio = document.getElementById('gameAudio');
            gameAudio.volume = 0.2;
        }
        let isMuted = true;
        let soundIcon = '▶️';
        let firstSpacebarPressedForAudio = false; // For the audio to only start once when spacebar is pressed

        function drawSpeakerIcon() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            ctx.fillText(soundIcon, CANVAS_WIDTH - 30, 30);
        }

        function toggleMute() {
            isMuted = !isMuted;
            if (isMuted) {
                gameAudio.pause();
                soundIcon = '▶️'
            } else {
                gameAudio.play();
                soundIcon = '⏸️';
            }
            drawSpeakerIcon(); // Redraw the speaker icon
        }

        function handleMuteToggle(e) {
            let clientX, clientY;
            if (e.type === 'click') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchstart') {
                // Prevent default behavior to avoid double handling if 'click' event also fires
                e.preventDefault();
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // Check if the event occurred within the speaker icon bounds
            if (x > CANVAS_WIDTH - 35 && x < CANVAS_WIDTH && y > 0 && y < 40) {
                if (!firstSpacebarPressedForAudio) {
                    firstSpacebarPressedForAudio = true;
                }
                toggleMute();
            }
        }

        // Listen for click and touchstart events
        canvas.addEventListener('click', handleMuteToggle);
        canvas.addEventListener('touchstart', handleMuteToggle, { passive: false });
        //------------------------------ 🔺 Audio & Mute 🔺 ------------------------------/
        /////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Game over 🔻 ------------------------------/
        let gameOver = false;
        let topTenScores = [];

        function saveScore(score) {
            topTenScores.push(score);
            topTenScores.sort((a, b) => b - a);
            topTenScores = topTenScores.slice(0, 10);
        }

        function displayTopTenScores() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            let TopTenScoresTextMetrics = ctx.measureText('Top 10 Scores:');
            let TopTenScoresTextWidth = TopTenScoresTextMetrics.width;
            ctx.fillText('Top 10 Scores:', CANVAS_WIDTH / 2 - TopTenScoresTextWidth / 2, (CANVAS_HEIGHT / 4) + 100);
            for (let i = 0; i < topTenScores.length; i++) {
                let scoreListItemTextMetrics = ctx.measureText(`${topTenScores[i]}`);
                let scoreListItemTextWidth = scoreListItemTextMetrics.width;
                ctx.fillText(`${topTenScores[i]}`, CANVAS_WIDTH / 2 - scoreListItemTextWidth / 2, ((CANVAS_HEIGHT / 4) + 100) + ((i + 1) * 30));
            }
        }

        function gameOverHandler() {
            if (!isMuted) {
                gameAudio.pause();
                soundIcon = '▶️';
            }
            saveScore(score); // Save the score

            // Clear canvas and display game over message
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = 'black';
            ctx.font = '50px Rubik';
            const gameOverTextMetrics = ctx.measureText("GAME OVER");
            const gameOverTextWidth = gameOverTextMetrics.width;
            ctx.fillText("GAME OVER", CANVAS_WIDTH / 2 - gameOverTextWidth / 2, CANVAS_HEIGHT / 4);

            // Display the player's score
            ctx.fillStyle = 'black';
            ctx.font = '30px Rubik';
            const scoreTextMetrics = ctx.measureText(`Score: ${score}`);
            const scoreTextWidth = scoreTextMetrics.width;
            ctx.fillText(`Score: ${score}`, CANVAS_WIDTH / 2 - scoreTextWidth / 2, (CANVAS_HEIGHT / 4) + 50);

            // Display top 10 scores
            displayTopTenScores();

            // Display play again button above the GAME OVER text
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            const playAgainTextMetrics = ctx.measureText("Play again!");
            const playAgainTextWidth = playAgainTextMetrics.width;
            ctx.fillText("Play again", CANVAS_WIDTH / 2 - playAgainTextWidth / 2, CANVAS_HEIGHT / 8);

        }

        function handlePlayAgainInteraction(e) {
            let clientX, clientY;
            if (e.type === 'click') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchstart') {
                e.preventDefault();
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            if (gameOver) {
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                // Check if the interaction occurred within the play again button bounds
                if (x > CANVAS_WIDTH / 2 - 50 && x < CANVAS_WIDTH / 2 + 50 && y > CANVAS_HEIGHT / 8 - 20 && y < CANVAS_HEIGHT / 8) {
                    resetGame();
                }
            }
        }

        // Listen for click and touchstart events
        canvas.addEventListener('click', handlePlayAgainInteraction);
        canvas.addEventListener('touchstart', handlePlayAgainInteraction, { passive: false });

        //----------------------------- 🔺 Game over 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Reset game 🔻 -----------------------------/
        function resetGame() {
            gameOver = false;
            player = {
                x: (CANVAS_WIDTH / 2) - 10,
                y: playerStartY,
                width: playerWidth,
                height: playerHeight,
                speed: 50, // horizonal max speed
                velX: 0,
                velY: 0,
                jumping: false,
                onPlatform: true
            };
            platforms = [];
            platformCounter = 0;
            if (!isMuted) {
                gameAudio.play();
                soundIcon = '⏸️';
            }
            // firstSpacebarPressedForAudio = false;
            heighestPlatformIndex = 9;
            score = 0;
            platformWidthRange = [...initialPlatformWidthRange];
            platformGap = initialPlatformGap;
            for (let i = 0; i < 10; i++) {
                let [tempWidth, tempX] = randomWidthAndX();
                platforms.push({
                    x: tempX,
                    y: CANVAS_HEIGHT - (platformGap * i) - 50,
                    width: tempWidth,
                    height: platformHeight,
                    number: platformCounter,
                    playerStandTime: 0, // time in milliseconds the player has been on the platform
                    falling: false, // indicates whether the platform is falling
                    fallSpeed: 0, // speed at which the platform falls
                    xToDrawFromInSprite: Math.random() * (4628 - tempWidth)
                });
                if (Math.random() < 0.05 && platformCounter % 10 != 0) {
                    const enemyType = Math.random() < 0.5 ? 1 : 2;
                    platforms[i].enemy = createEnemy(enemyType, platforms[i]);
                }
                platformCounter++;
            }
            updateGame();
        }
        //----------------------------- 🔺 Reset game 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Collision detection 🔻 -----------------------------/
        function calculateTOI(platform) {
            if (player.velY <= 0) return Infinity; // Ignore if moving upwards or stationary

            let effectivePlatformY = platform.y;
            if (platform.verticalMoving) {
                // If platform is moving upwards, adjust its effective position for collision detection
                let sineWave = Math.sin(platform.currentVerticalMovement);
                effectivePlatformY -= sineWave * platform.maxVerticalMovement * platform.verticalSpeed;
            }

            const timeToCollide = (effectivePlatformY - player.height - player.y) / player.velY;
            return timeToCollide >= 0 && timeToCollide <= 1 ? timeToCollide : Infinity;
        }

        // Collision detection and handling function
        function platformYCollision(platforms) {
            let collisionDetected = false;

            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                const toi = calculateTOI(platform);

                if (toi !== Infinity) {
                    collisionDetected = true;
                    break; // Stop checking after the first collision is found
                }
            }

            return collisionDetected;
        }
        //----------------------------- 🔺 Collision detection 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Loop variables 🔻 ------------------------------/
        let heighestPlatformIndex = 9; // The platform that needs to be generated - should be generated above the heighest platform
        let score = 0;
        let gameFrame = 0;
        //------------------------------ 🔺 Loop variables 🔺 ------------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Game loop 🔻 ------------------------------/
        function updateGame() {
            if (!gameOver) {

                if (player.jumping && player.velY < 0) {
                    currentPlayerState = player.velX > 0 ? playerStates.jumpRight : playerStates.jumpLeft;
                } else if (player.velY > 0) {
                    currentPlayerState = player.velX > 0 ? playerStates.fallRight : playerStates.fallLeft;
                } else if (player.velX > 0.2) {
                    currentPlayerState = playerStates.runRight;
                    player.lastRunningDirection = 'right';
                } else if (player.velX < -0.2) {
                    currentPlayerState = playerStates.runLeft;
                    player.lastRunningDirection = 'left';
                } else {
                    currentPlayerState = player.lastRunningDirection === 'right' ? playerStates.idleRight : playerStates.idleLeft;
                }

                // Check key inputs
                if (keys[39]) { // right arrow
                    if (player.velX < player.speed) {
                        player.velX += 0.33;
                    }
                }
                if (keys[37]) { // left arrow
                    if (player.velX > -player.speed) {
                        player.velX -= 0.33;
                    }
                }

                // trying the possibility of not stopping the player when left/right key is pressed
                // if (!keys[37] && !keys[39]) {
                //     player.velX *= friction;
                // }

                player.velX *= friction;

                player.x += player.velX;
                player.y += player.velY;

                const hasCollided = platformYCollision(platforms);

                if (!hasCollided) {
                    player.velY += gravity; // Apply gravity if no collision
                }

                // Screen scroll
                if (player.y < CANVAS_HEIGHT / 4) { // player jumped above 1/4 of the canvas
                    player.y += Math.abs(player.velY); // If player is jumping (velocity is negative), cancel the movement by adding absolute value velocity (add positive value)

                    // Go over all platforms and move them down. If needed, move to the top
                    platforms.forEach(function callback(platform, index) {
                        platform.y += Math.abs(player.velY); // Move platforms down with the same amount of positive velocity
                        // if platform has enemy - move the enemy down
                        if (platform.enemy) {
                            platform.enemy.y += Math.abs(player.velY);
                        }
                        if (platform.star) {
                            platform.star.y += Math.abs(player.velY);
                        }
                        repositionPlatform(platform, index);
                    });
                }
                // Collision with the canvas edges
                if (player.x + player.width >= CANVAS_WIDTH) {
                    if (player.velX > 0) {
                        player.x = CANVAS_WIDTH - player.width;
                        if (player.jumping) { // Bounce off the wall while in the air after jumping
                            player.velX *= -0.5;
                        }
                    }
                } else if (player.x <= 0) {
                    if (player.velX < 0) {
                        player.x = 0;
                        if (player.jumping) { // Bounce off the wall while in the air after jumping
                            player.velX *= -0.5;
                        }
                    }
                }

                if (player.y >= CANVAS_HEIGHT - player.height) {
                    player.y = CANVAS_HEIGHT - player.height;
                    player.jumping = false;
                    player.onPlatform = false;
                    player.velY = 0;
                    gameOver = true;
                }

                // Platform collision
                player.onPlatform = false; // reset the flag, so it can be set to true if player is on a platform
                platforms.forEach(function callback(platform, index) {
                    let toi = calculateTOI(platform); // Calculate time of impact with the current platform
                    if (toi !== Infinity && player.velY > 0 && player.x + player.width > platform.x && player.x < platform.x + platform.width) {
                        player.jumping = false;
                        player.velY = 0;
                        player.y = platform.y - player.height;
                        player.onPlatform = true;

                        if (score < platform.number) { // Update the score
                            score = platform.number;
                        }

                        if (platform.falling === false && platform.number % 10 != 0) {
                            platform.playerStandTime += 1; // Increment platform's stand time

                            if (platform.playerStandTime > 240) {
                                platform.falling = true;
                                platform.isMoving = false;
                            }
                        }
                    } else {
                        platform.playerStandTime = 0; // Reset if player is not on platform
                    }
                });

                // Check for player-enemy collisions
                platforms.forEach(platform => {
                    if (platform.enemy) {
                        updateEnemyPosition(platform.enemy, platform);
                        if (checkPlayerEnemyCollision(platform.enemy)) {
                            gameOver = true;
                        }
                    }
                });

                // Check for player-star collisions
                platforms.forEach(platform => {
                    if (platform.star) {
                        if (checkPlayerStarCollision(platform.star)) {
                            platform.star = null;
                            collectStar();
                        }
                    }
                });

                // Handle falling platforms
                platforms.forEach(function callback(platform, index) {
                    if (platform.falling) {
                        platform.fallSpeed += gravity; // Increase fall speed by gravity
                        platform.y += platform.fallSpeed; // Apply fall speed
                        // if the platform has enemy - move the enemy down
                        if (platform.enemy) {
                            platform.enemy.y += platform.fallSpeed;
                        }
                        if (platform.star) {
                            platform.star.y += platform.fallSpeed;
                        }
                    }
                    repositionPlatform(platform, index);
                });

                // Handle vertical moving platforms
                platforms.forEach(platform => {
                    updateVerticalMovement(platform);
                });

                // Clear canvas
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);


                // Draw platforms
                platforms.forEach(function callback(platform, index) {
                    ctx.drawImage(platformsImage, platform.xToDrawFromInSprite, platformAnimation[Math.floor(platform.number / 10) % 10], platform.width, 665, platform.x, platform.y, platform.width, platform.height);
                    if (platform.number % 10 == 0) {
                        // Draw a white rectangle to be the background of the number
                        const metrics = ctx.measureText(platform.number);
                        const textWidth = metrics.width;
                        const marginBetweenTextAndRectangle = 2;
                        ctx.fillStyle = 'white';
                        ctx.fillRect(platform.x + platform.width / 2 - textWidth / 2 - marginBetweenTextAndRectangle, platform.y + platform.height / 2 - 10, textWidth + marginBetweenTextAndRectangle * 2, 20);
                        // Draw the number
                        ctx.fillStyle = 'black';
                        ctx.font = '19px Rubik';
                        ctx.fillText(platform.number, platform.x + platform.width / 2 - textWidth / 2, platform.y + platform.height / 2 + 7);
                    }

                    // Draw enemy if exists
                    if (platform.enemy) {
                        enemyAnimationProgress = Math.floor(gameFrame / enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].enemyAnimationDelayer) % enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].data.length;
                        ctx.drawImage(platform.enemy.direction === 1 ? enemiesImage : enemiesImageReversed,
                            enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].data[enemyAnimationProgress].x,
                            enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].data[enemyAnimationProgress].y,
                            enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].data[enemyAnimationProgress].width,
                            enemyAnimation[platform.enemy.type - 1][1 - platform.enemy.direction].data[enemyAnimationProgress].height,
                            platform.enemy.x, platform.enemy.y, platform.enemy.width, platform.enemy.height);
                    }

                    // Draw star if exists
                    if (platform.star) {
                        platform.star.starAnimationProgress = Math.floor(gameFrame / starAnimation.playerAnimationDelayer) % starAnimation.data.length;
                        ctx.drawImage(starImage,
                            starAnimation.data[platform.star.starAnimationProgress].x,
                            starAnimation.data[platform.star.starAnimationProgress].y,
                            starAnimation.data[platform.star.starAnimationProgress].width,
                            starAnimation.data[platform.star.starAnimationProgress].height,
                            platform.star.x, platform.star.y, platform.star.width, platform.star.height);
                    }
                });

                // // Draw player
                let finalPlayerImage = null;
                if (player.power) {
                    finalPlayerImage = currentPlayerState < 4 ? playerImageYellow : playerImageReversedYellow;
                } else {
                    finalPlayerImage = currentPlayerState < 4 ? playerImage : playerImageReversed;
                }
                playerAnimationProgress = Math.floor(gameFrame / playerAnimations[currentPlayerState].playerAnimationDelayer) % playerAnimations[currentPlayerState].data.length;
                ctx.drawImage(finalPlayerImage,
                    playerAnimations[currentPlayerState].data[playerAnimationProgress].x,
                    playerAnimations[currentPlayerState].data[playerAnimationProgress].y,
                    playerAnimations[currentPlayerState].data[playerAnimationProgress].width,
                    playerAnimations[currentPlayerState].data[playerAnimationProgress].height,
                    player.x, player.y, player.width, player.height);


                // Draw score
                ctx.fillStyle = 'white';
                ctx.font = '26px Rubik';
                ctx.fillText('Score: ' + score, 10, 30);

                // Draw power-up timer
                if (player.power) {
                    ctx.fillStyle = 'white';
                    ctx.font = '26px Rubik';
                    ctx.fillText('Power-up: ' + (((starPowerTimeLeft - new Date().getTime()) / 1000).toFixed(1)), 10, 70);
                }

                drawSpeakerIcon();


                gameFrame++;
                requestAnimationFrame(updateGame); // Loop
            } else {
                gameOverHandler();
            }
        }
        //------------------------------ 🔺 Game loop 🔺 ------------------------------/

        updateGame();
    </script>
</body>

</html>