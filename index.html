<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game with Screen Scroll</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            -webkit-user-select: none;
            /* Safari */
            -ms-user-select: none;
            /* IE 10 and IE 11 */
            user-select: none;
            /* Standard syntax */
        }

        #gameCanvas {
            background-color: #87CEEB;
        }
    </style>
</head>

<body>
    <audio id="gameAudio" src="icy-remix.mp3"></audio>
    <audio id="gameAudioLower" src="icy-remix-lower-volume.mp3"></audio>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        //----------------------------- 🔻 Constants 🔻 -----------------------------/
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const animationImage = new Image();
        animationImage.src = 'MegaMan.png';
        const animationImageReversed = new Image();
        animationImageReversed.src = 'MegaManReversed.png';
        const playerStates = { idleRight: 0, jumpRight: 1, runRight: 2, fallRight: 3, idleLeft: 4, jumpLeft: 5, runLeft: 6, fallLeft: 7 };
        let currentPlayerState = playerStates.idleRight;
        const spriteAnimations = [
            {
                name: 'idleRight',
                playerAnimationDelayer: 20,
                data: [
                    { x: 60 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 95 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 130 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 166 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 201 - (33 - 27), y: 353, width: 33, height: 34 }
                ]
            },
            {
                name: 'jumpRight',
                playerAnimationDelayer: 200,
                data: [
                    // { x: 484 - (33 - 21), y: 428, width: 33, height: 38 },
                    { x: 517 - (33 - 32), y: 426, width: 33, height: 40 }
                    // { x: 556 - (33 - 34), y: 431, width: 33, height: 38 },
                    // { x: 599 - (33 - 27), y: 433, width: 33, height: 33 }
                ]
            },
            {
                name: 'runRight',
                playerAnimationDelayer: 13,
                data: [
                    { x: 54, y: 426, width: 33, height: 35 },
                    { x: 105 - (33 - 25), y: 427, width: 33, height: 34 },
                    { x: 146 - (33 - 17), y: 426, width: 33, height: 35 },
                    { x: 178 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 221 - (33 - 29), y: 427, width: 33, height: 33 },
                    { x: 266, y: 426, width: 33, height: 35 },
                    { x: 314 - (33 - 25), y: 427, width: 33, height: 34 },
                    { x: 356 - (33 - 17), y: 426, width: 33, height: 35 },
                    { x: 390 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 429 - (33 - 29), y: 427, width: 33, height: 33 }

                ]
            },
            {
                name: 'fallRight',
                playerAnimationDelayer: 200,
                data: [
                    // { x: 484 - (33 - 21), y: 428, width: 33, height: 38 },
                    { x: 556 - (33 - 34), y: 431, width: 33, height: 38 }
                    // { x: 556 - (33 - 34), y: 431, width: 33, height: 38 },
                    // { x: 599 - (33 - 27), y: 433, width: 33, height: 33 }
                ]
            },
            {
                name: 'idleLeft',
                playerAnimationDelayer: 20,
                data: [
                    { x: 915 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 880 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 845 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 809 - (33 - 27), y: 353, width: 33, height: 34 },
                    { x: 775 - (33 - 27), y: 353, width: 33, height: 34 }
                ]
            },
            {
                name: 'jumpLeft',
                playerAnimationDelayer: 200,
                data: [
                    { x: 453 - (33 - 32), y: 426, width: 33, height: 40 }
                ]
            },
            {
                name: 'runLeft',
                playerAnimationDelayer: 13,
                data: [
                    { x: 915, y: 426, width: 33, height: 35 },
                    { x: 880 - (33 - 25), y: 427, width: 33, height: 34 },

                    { x: 853 - (33 - 17), y: 426, width: 33, height: 35 },

                    { x: 805 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 755 - (33 - 29), y: 427, width: 33, height: 33 },
                    { x: 703, y: 426, width: 33, height: 35 },
                    { x: 670 - (33 - 25), y: 427, width: 33, height: 34 },

                    { x: 643 - (33 - 17), y: 426, width: 33, height: 35 },

                    { x: 591 - (33 - 26), y: 426, width: 33, height: 35 },
                    { x: 548 - (33 - 29), y: 427, width: 33, height: 33 }

                ]
            },
            {
                name: 'fallLeft',
                playerAnimationDelayer: 200,
                data: [
                    { x: 412 - (33 - 34), y: 431, width: 33, height: 38 }
                ]
            },
        ];
        let animationProgress = 0;
        //----------------------------- 🔺 Constants 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Resize canvas for mobile 🔻 -----------------------------/
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;

            // Regular expressions for mobile User Agent detection
            return /android/i.test(userAgent) || /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
        }

        function resizeCanvas() {
            if (isMobileDevice()) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        //----------------------------- 🔺 Resize canvas for mobile 🔺 -----------------------------/
        /////////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Game settings 🔻 -----------------------------/
        let gravity = 0;
        if (isMobileDevice()) {
            gravity = 1.75;
        } else {
            gravity = 0.48;
        }
        const friction = 0.95;
        const baseJump = -11; // Base jump velocity
        //----------------------------- 🔺 Game settings 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Player 🔻 -----------------------------/
        const playerWidth = 35;
        const playerHeight = 35;
        const playerStartY = CANVAS_HEIGHT - 100;
        let player = {
            x: (CANVAS_WIDTH / 2) - 10,
            y: playerStartY,
            width: playerWidth,
            height: playerHeight,
            speed: 50, // horizonal max speed
            velX: 0,
            velY: 0,
            jumping: false,
            onPlatform: true,
            lastRunningDirection: 'right',
            stuckOnSide: 1 // 0 = stuck, 1 = not stuck - preperation for future bug fix
        };
        //----------------------------- 🔺 Player 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Enemies 🔻 -----------------------------/
        const enemyWidth = 20;
        const enemyHeight = 20;
        function createEnemy(type, platform) {
            // calculate random x position for the enemy - but make sure it's within the canvas
            let randomEnemyX = platform.x + Math.random() * (platform.width - 20);
            if (randomEnemyX < 0) {
                randomEnemyX = 10; // margin from the left
            } else if (randomEnemyX + 20 > CANVAS_WIDTH) {
                randomEnemyX = CANVAS_WIDTH - 30; // margin from the right
            }
            return {
                type,
                x: randomEnemyX, // Random starting position on the platform
                y: platform.y - 20, // Positioned above the platform
                width: enemyWidth,
                height: enemyHeight,
                speed: type === 2 ? 1 : 0, // Type 2 enemies move
                direction: 1 // Direction for moving enemies
            };
        }

        function updateEnemyPosition(enemy, platform) {
            if (enemy.type === 2) {
                enemy.x += enemy.speed * enemy.direction;
                // Change direction if enemy reaches the edge of the platform
                if (enemy.x <= Math.max(platform.x, 0) || enemy.x + enemy.width >= Math.min(platform.x + platform.width, CANVAS_WIDTH)) {
                    enemy.direction *= -1;
                }
            }
        }

        function checkPlayerEnemyCollision(player, enemy) {
            return player.x < enemy.x + enemy.width &&
                player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height &&
                player.y + player.height > enemy.y;
        }
        //----------------------------- 🔺 Enemies 🔺 -----------------------------/
        ////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Platforms 🔻 -----------------------------/
        let platforms = [];
        let platformCounter = 0;
        const platformHeight = 10;

        const initialPlatformWidthRange = [200, 350];
        const widthRangeBottomValueDecreaseStep = 10; // The amount by which the range decreases
        const widthRangeTopValueDecreaseStep = 20; // The amount by which the range decreases
        const widthRangeInterval = 20; // Interval after which the range decreases

        let platformWidthRange = [...initialPlatformWidthRange];

        const initialPlatformGap = 75;
        const gapIncreaseStep = 20; // The amount by which the gap increases
        const gapInterval = 10; // Interval after which the gap increases

        let platformGap = initialPlatformGap;


        let enemyOnPlatformRatio = 0.05; // 5% chance of enemy on platform
        let verticalMovingPlatformRatio = 0.06; // 6% chance of vertical moving platform

        // Generate random width for the platform
        function randomWidth() {
            if ((platformCounter - 1) % widthRangeInterval === 0 && platformCounter !== 0 && platformCounter !== 1) {
                platformWidthRange[0] = Math.max(platformWidthRange[0] - widthRangeBottomValueDecreaseStep, 50); // Lower limit to prevent too narrow platforms
                platformWidthRange[1] = Math.max(platformWidthRange[1] - widthRangeTopValueDecreaseStep, platformWidthRange[0]);
            }

            if (platformCounter % 10 === 0) {
                return CANVAS_WIDTH;
            } else {
                return Math.random() * (platformWidthRange[1] - platformWidthRange[0]) + platformWidthRange[0];
            }
        }


        // Generate random x for the platform
        function randomX(platformWidth) {
            // return Math.random() * (CANVAS_WIDTH - (platformWidth - (platformWidth / 2))) - platformWidth / 2;
            if (platformWidth == CANVAS_WIDTH) {
                return 0;
            } else {
                return (Math.random() * CANVAS_WIDTH) - platformWidth / 2;
            }
        }

        // Generate random width AND random x for the platform
        function randomWidthAndX() {
            let width = randomWidth(platformCounter);
            let x = randomX(width);
            return [width, x];
        }

        function chooseIfEnemyOnPlatform(platform) {
            if (Math.random() < enemyOnPlatformRatio && platformCounter % 10 != 0) {
                const enemyType = Math.random() < 0.5 ? 1 : 2;
                platform.enemy = createEnemy(enemyType, platform);
            }
        }

        function chooseIfVerticalMovingPlatform(platform) {
            if (Math.random() < verticalMovingPlatformRatio && platformCounter % 10 != 0) { // Approximately 6% chance
                platform.verticalMoving = true;
                platform.verticalSpeed = 0.15; // Speed of vertical movement
                platform.maxVerticalMovement = 50; // Maximum distance the platform moves vertically
                platform.currentVerticalMovement = 0; // Current distance moved
                platform.movingUp = Math.random() < 0.5; // Randomly decide initial direction
            }
        }

        // Generate the 10 platforms
        for (let i = 0; i < 10; i++) {
            let [tempWidth, tempX] = randomWidthAndX();
            platforms.push({
                x: tempX,
                y: CANVAS_HEIGHT - (platformGap * i) - 50,
                width: tempWidth,
                height: platformHeight,
                number: platformCounter,
                playerStandTime: 0, // time in milliseconds the player has been on the platform
                falling: false, // indicates whether the platform is falling
                fallSpeed: 0 // speed at which the platform falls
            });

            chooseIfEnemyOnPlatform(platforms[i]);
            chooseIfVerticalMovingPlatform(platforms[i]);

            platformCounter++;
        }

        function repositionPlatform(platform, index) {
            if (platform.y - enemyHeight > CANVAS_HEIGHT) { // If platform falls off-screen, reset it
                updatePlatformGap();
                let [tempWidth, tempX] = randomWidthAndX();
                platform.y = platforms[heighestPlatformIndex].y - platformGap; // Move platform to the top
                platform.x = tempX;
                platform.width = tempWidth;
                platform.number = platformCounter; // Increase platform number
                heighestPlatformIndex = index; // Update the heighest platform index
                platform.playerStandTime = 0;
                platform.falling = false;
                platform.fallSpeed = 0;

                chooseIfEnemyOnPlatform(platform);
                chooseIfVerticalMovingPlatform(platform);

                platformCounter++;
            }
        }

        function updateVerticalMovement(platform) {
            if (platform.verticalMoving) {
                platform.currentVerticalMovement += 0.075; // lower = larger distance

                // Use sine wave for smooth easing transition
                let sineWave = Math.sin(platform.currentVerticalMovement * platform.verticalSpeed);
                platform.y += sineWave * platform.verticalSpeed;

                // Move enemy if exists
                if (platform.enemy) {
                    platform.enemy.y += sineWave * platform.verticalSpeed;
                }
            }
        }

        function updatePlatformGap() {
            // Check if the current platform number is divisible by the gapInterval (10)
            // and it's not the first platform (number 0)
            // This will update the gap starting from the 11th, 21st, 31st platforms, etc.
            if ((platformCounter - 1) % gapInterval === 0 && platformCounter !== 0 && platformCounter !== 1) {
                platformGap += gapIncreaseStep;
            }
        }

        //----------------------------- 🔺 Platforms 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Key events 🔻 ------------------------------/
        let keys = [];
        window.addEventListener('keydown', function (e) {
            keys[e.keyCode] = true;
            if (e.keyCode == 32 && !player.jumping && player.onPlatform && !player.velY > 0) { // Space key for jump
                player.jumping = true;
                if (player.velX > 0) {
                    currentPlayerState = playerStates.jumpRight;
                } else {
                    currentPlayerState = playerStates.jumpLeft;
                }
                animationProgress = 0;
                // player.velY = baseJump - Math.abs(player.velX); // Old "running faster = higher jump" - linear growth
                player.velY = baseJump - Math.pow(Math.abs(player.velX), 2) * 0.2; // New "running faster = higher jump" - exponential growth
                if (!isSpacebarPressedForAudio) {
                    isSpacebarPressedForAudio = true;
                    toggleMute();
                }
            }
        });
        window.addEventListener('keyup', function (e) {
            keys[e.keyCode] = false;
        });
        //------------------------------ 🔺 Key events 🔺 ------------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Touch events for mobile 🔻 ------------------------------/

        // Variables to store touch positions and time
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchX;
        let lastTouchY;
        let lastTouchTime;
        let isSwipeUpDetected = false; // Flag to check if swipe up is already detected

        // Add touch event listeners
        canvas.addEventListener('touchstart', function (e) {
            if (!isSpacebarPressedForAudio) {
                isSpacebarPressedForAudio = true;
                toggleMute();
            }
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            lastTouchX = touchStartX;
            lastTouchY = touchStartY;
            lastTouchTime = Date.now(); // Record the start time
            isSwipeUpDetected = false; // Reset swipe up detection
        }, { passive: false });

        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault();
            let touchMoveX = e.touches[0].clientX;
            let touchMoveY = e.touches[0].clientY;
            let currentTime = Date.now();

            let deltaX = touchMoveX - lastTouchX;
            let deltaTime = currentTime - lastTouchTime;

            // Normalize the swipe speed
            let swipeSensitivity = 5; // Adjust for sensitivity - higher = sensitive is stronger
            let maxSwipeSpeed = 2; // Maximum speed per swipe - higher = faster max speed

            if (deltaTime > 0) { // Avoid division by zero
                let swipeSpeed = (deltaX / deltaTime) * swipeSensitivity;
                swipeSpeed = Math.max(Math.min(swipeSpeed, maxSwipeSpeed), -maxSwipeSpeed);
                player.velX += swipeSpeed;
                player.velX = Math.max(Math.min(player.velX, player.speed), -player.speed);
            }

            // Upward swipe detection
            if (!player.jumping && player.onPlatform && lastTouchY - touchMoveY > 10) { // 10 = minimum swipe distance
                player.jumping = true;
                if (player.velX > 0) {
                    currentPlayerState = playerStates.jumpRight;
                } else {
                    currentPlayerState = playerStates.jumpLeft;
                }
                animationProgress = 0;
                player.velY = baseJump * 1.9 - Math.abs(player.velX) * 0.75;
                isSwipeUpDetected = true;
            }

            lastTouchX = touchMoveX;
            lastTouchY = touchMoveY;
            lastTouchTime = currentTime;
        }, { passive: false });

        canvas.addEventListener('touchend', function (e) {
            e.preventDefault();
            // Reset variables on touch end
            touchStartX = 0;
            touchStartY = 0;
            lastTouchX = 0;
            lastTouchY = 0;
            lastTouchTime = 0;
            player.velX = 0; // Adjust for smoother stopping
            isSwipeUpDetected = false; // Reset swipe up detection
        }, { passive: false });

        //------------------------------ 🔺 Touch events for mobile 🔺 ------------------------------/
        ////////////////////////////////////////////////////////////////////////////////////////
        // ------------------------------ 🔻 Audio & Mute 🔻 ------------------------------/
        let gameAudio = null;
        if (isMobileDevice()) {
            gameAudio = document.getElementById('gameAudioLower');
        } else {
            gameAudio = document.getElementById('gameAudio');
            gameAudio.volume = 0.2;
        }
        let isMuted = true;
        let soundIcon = '▶️';
        let isSpacebarPressedForAudio = false; // For the audio to only start once when spacebar is pressed

        function drawSpeakerIcon() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            ctx.fillText(soundIcon, CANVAS_WIDTH - 30, 30);
        }

        function toggleMute() {
            isMuted = !isMuted;
            if (isMuted) {
                gameAudio.pause();
                soundIcon = '▶️'
            } else {
                gameAudio.play();
                soundIcon = '⏸️';
            }
            drawSpeakerIcon(); // Redraw the speaker icon
        }

        function handleMuteToggle(e) {
            let clientX, clientY;
            if (e.type === 'click') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchstart') {
                // Prevent default behavior to avoid double handling if 'click' event also fires
                e.preventDefault();
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // Check if the event occurred within the speaker icon bounds
            if (x > CANVAS_WIDTH - 35 && x < CANVAS_WIDTH && y > 0 && y < 40) {
                if (!isSpacebarPressedForAudio) {
                    isSpacebarPressedForAudio = true;
                }
                toggleMute();
            }
        }

        // Listen for click and touchstart events
        canvas.addEventListener('click', handleMuteToggle);
        canvas.addEventListener('touchstart', handleMuteToggle, { passive: false });
        //------------------------------ 🔺 Audio & Mute 🔺 ------------------------------/
        /////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Game over 🔻 ------------------------------/
        let gameOver = false;
        let topTenScores = [];

        function saveScore(score) {
            topTenScores.push(score);
            topTenScores.sort((a, b) => b - a);
            topTenScores = topTenScores.slice(0, 10);
        }

        function displayTopTenScores() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            let TopTenScoresTextMetrics = ctx.measureText('Top 10 Scores:');
            let TopTenScoresTextWidth = TopTenScoresTextMetrics.width;
            ctx.fillText('Top 10 Scores:', CANVAS_WIDTH / 2 - TopTenScoresTextWidth / 2, (CANVAS_HEIGHT / 4) + 100);
            for (let i = 0; i < topTenScores.length; i++) {
                let scoreListItemTextMetrics = ctx.measureText(`${topTenScores[i]}`);
                let scoreListItemTextWidth = scoreListItemTextMetrics.width;
                ctx.fillText(`${topTenScores[i]}`, CANVAS_WIDTH / 2 - scoreListItemTextWidth / 2, ((CANVAS_HEIGHT / 4) + 100) + ((i + 1) * 30));
            }
        }

        function gameOverHandler() {
            if (!isMuted) {
                gameAudio.pause();
                soundIcon = '▶️';
            }
            saveScore(score); // Save the score

            // Clear canvas and display game over message
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = 'black';
            ctx.font = '50px Rubik';
            const gameOverTextMetrics = ctx.measureText("GAME OVER");
            const gameOverTextWidth = gameOverTextMetrics.width;
            ctx.fillText("GAME OVER", CANVAS_WIDTH / 2 - gameOverTextWidth / 2, CANVAS_HEIGHT / 4);

            // Display the player's score
            ctx.fillStyle = 'black';
            ctx.font = '30px Rubik';
            const scoreTextMetrics = ctx.measureText(`Score: ${score}`);
            const scoreTextWidth = scoreTextMetrics.width;
            ctx.fillText(`Score: ${score}`, CANVAS_WIDTH / 2 - scoreTextWidth / 2, (CANVAS_HEIGHT / 4) + 50);

            // Display top 10 scores
            displayTopTenScores();

            // Display play again button above the GAME OVER text
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            const playAgainTextMetrics = ctx.measureText("Play again!");
            const playAgainTextWidth = playAgainTextMetrics.width;
            ctx.fillText("Play again", CANVAS_WIDTH / 2 - playAgainTextWidth / 2, CANVAS_HEIGHT / 8);

        }

        function handlePlayAgainInteraction(e) {
            let clientX, clientY;
            if (e.type === 'click') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchstart') {
                e.preventDefault();
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            if (gameOver) {
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                // Check if the interaction occurred within the play again button bounds
                if (x > CANVAS_WIDTH / 2 - 50 && x < CANVAS_WIDTH / 2 + 50 && y > CANVAS_HEIGHT / 8 - 20 && y < CANVAS_HEIGHT / 8) {
                    resetGame();
                }
            }
        }

        // Listen for click and touchstart events
        canvas.addEventListener('click', handlePlayAgainInteraction);
        canvas.addEventListener('touchstart', handlePlayAgainInteraction, { passive: false });

        //----------------------------- 🔺 Game over 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Reset game 🔻 -----------------------------/
        function resetGame() {
            gameOver = false;
            player = {
                x: (CANVAS_WIDTH / 2) - 10,
                y: playerStartY,
                width: playerWidth,
                height: playerHeight,
                speed: 50, // horizonal max speed
                velX: 0,
                velY: 0,
                jumping: false,
                onPlatform: true
            };
            platforms = [];
            platformCounter = 0;
            if (!isMuted) {
                gameAudio.play();
                soundIcon = '⏸️';
            }
            // isSpacebarPressedForAudio = false;
            heighestPlatformIndex = 9;
            score = 0;
            platformWidthRange = [...initialPlatformWidthRange];
            platformGap = initialPlatformGap;
            for (let i = 0; i < 10; i++) {
                let [tempWidth, tempX] = randomWidthAndX();
                platforms.push({
                    x: tempX,
                    y: CANVAS_HEIGHT - (platformGap * i) - 50,
                    width: tempWidth,
                    height: platformHeight,
                    number: platformCounter,
                    playerStandTime: 0, // time in milliseconds the player has been on the platform
                    falling: false, // indicates whether the platform is falling
                    fallSpeed: 0 // speed at which the platform falls
                });
                if (Math.random() < 0.05 && platformCounter % 10 != 0) {
                    const enemyType = Math.random() < 0.5 ? 1 : 2;
                    platforms[i].enemy = createEnemy(enemyType, platforms[i]);
                }
                platformCounter++;
            }
            updateGame();
        }
        //----------------------------- 🔺 Reset game 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Collision detection 🔻 -----------------------------/
        function calculateTOI(player, platform) {
            if (player.velY <= 0) return Infinity; // Ignore if moving upwards or stationary

            let effectivePlatformY = platform.y;
            if (platform.verticalMoving) {
                // If platform is moving upwards, adjust its effective position for collision detection
                let sineWave = Math.sin(platform.currentVerticalMovement * platform.verticalSpeed);
                effectivePlatformY -= sineWave * platform.verticalSpeed;
            }

            const timeToCollide = (effectivePlatformY - player.height - player.y) / player.velY;
            return timeToCollide >= 0 && timeToCollide <= 1 ? timeToCollide : Infinity;
        }

        // Collision detection and handling function
        function platformYCollision(player, platforms) {
            let collisionDetected = false;

            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                const toi = calculateTOI(player, platform);

                if (toi !== Infinity) {
                    collisionDetected = true;
                    break; // Stop checking after the first collision is found
                }
            }

            return collisionDetected;
        }
        //----------------------------- 🔺 Collision detection 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Loop variables 🔻 ------------------------------/
        let heighestPlatformIndex = 9; // The platform that needs to be generated - should be generated above the heighest platform
        let score = 0;
        let gameFrame = 0;
        //------------------------------ 🔺 Loop variables 🔺 ------------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Game loop 🔻 ------------------------------/
        function updateGame() {
            if (!gameOver) {

                if (player.jumping && player.velY < 0) {
                    currentPlayerState = player.velX > 0 ? playerStates.jumpRight : playerStates.jumpLeft;
                } else if (player.velY > 0) {
                    currentPlayerState = player.velX > 0 ? playerStates.fallRight : playerStates.fallLeft;
                } else if (player.velX > 0.2) {
                    currentPlayerState = playerStates.runRight;
                    player.lastRunningDirection = 'right';
                } else if (player.velX < -0.2) {
                    currentPlayerState = playerStates.runLeft;
                    player.lastRunningDirection = 'left';
                } else {
                    currentPlayerState = player.lastRunningDirection === 'right' ? playerStates.idleRight : playerStates.idleLeft;
                }

                // Check key inputs
                if (keys[39]) { // right arrow
                    if (player.velX < player.speed) {
                        player.velX += 0.33;
                    }
                }
                if (keys[37]) { // left arrow
                    if (player.velX > -player.speed) {
                        player.velX -= 0.33;
                    }
                }

                // trying the possibility of not stopping the player when left/right key is pressed
                // if (!keys[37] && !keys[39]) {
                //     player.velX *= friction;
                // }

                player.velX *= friction;

                player.x += player.velX;
                player.y += player.velY;

                const hasCollided = platformYCollision(player, platforms);

                if (!hasCollided) {
                    player.velY += gravity; // Apply gravity if no collision
                }

                // Screen scroll
                if (player.y < CANVAS_HEIGHT / 4) { // player jumped above 1/4 of the canvas
                    player.y += Math.abs(player.velY); // If player is jumping (velocity is negative), cancel the movement by adding absolute value velocity (add positive value)

                    // Go over all platforms and move them down. If needed, move to the top
                    platforms.forEach(function callback(platform, index) {
                        platform.y += Math.abs(player.velY); // Move platforms down with the same amount of positive velocity
                        // if platform has enemy - move the enemy down
                        if (platform.enemy) {
                            platform.enemy.y += Math.abs(player.velY);
                        }
                        repositionPlatform(platform, index);
                    });
                }

                // Collision with the canvas edges
                if (player.x >= CANVAS_WIDTH - player.width) {
                    player.x = CANVAS_WIDTH - player.width;
                } else if (player.x <= 0) {
                    player.x = 0;
                }

                if (player.y >= CANVAS_HEIGHT - player.height) {
                    player.y = CANVAS_HEIGHT - player.height;
                    player.jumping = false;
                    player.onPlatform = false;
                    player.velY = 0;
                    gameOver = true;
                }

                // Platform collision
                player.onPlatform = false; // reset the flag, so it can be set to true if player is on a platform
                platforms.forEach(function callback(platform, index) {
                    let toi = calculateTOI(player, platform); // Calculate time of impact with the current platform
                    if (toi !== Infinity && player.velY > 0 && player.x + player.width > platform.x && player.x < platform.x + platform.width) {
                        player.jumping = false;
                        player.velY = 0;
                        player.y = platform.y - player.height;
                        player.onPlatform = true;

                        if (score < platform.number) { // Update the score
                            score = platform.number;
                        }

                        if (platform.falling === false && platform.number % 10 != 0) {
                            platform.playerStandTime += 1; // Increment platform's stand time

                            if (platform.playerStandTime > 240) {
                                platform.falling = true;
                                platform.isMoving = false;
                            }
                        }
                    } else {
                        platform.playerStandTime = 0; // Reset if player is not on platform
                    }
                });

                // Check for player-enemy collisions
                platforms.forEach(platform => {
                    if (platform.enemy) {
                        updateEnemyPosition(platform.enemy, platform);
                        if (checkPlayerEnemyCollision(player, platform.enemy)) {
                            gameOver = true;
                        }
                    }
                });

                // Handle falling platforms
                platforms.forEach(function callback(platform, index) {
                    if (platform.falling) {
                        platform.fallSpeed += gravity; // Increase fall speed by gravity
                        platform.y += platform.fallSpeed; // Apply fall speed
                        // if the platform has enemy - move the enemy down
                        if (platform.enemy) {
                            platform.enemy.y += platform.fallSpeed;
                        }
                    }
                    repositionPlatform(platform, index);
                });

                // Handle vertical moving platforms
                platforms.forEach(platform => {
                    updateVerticalMovement(platform);
                });

                // Clear canvas
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);


                // Draw platforms
                platforms.forEach(function callback(platform, index) {
                    if (platform.number % 10 == 0) {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height + 5);
                        // draw platforms number inside it
                        ctx.fillStyle = 'black';
                        ctx.font = '16px Rubik';
                        const metrics = ctx.measureText(platform.number);
                        const textWidth = metrics.width;
                        ctx.fillText(platform.number, platform.x + platform.width / 2 - textWidth / 2, platform.y + platform.height / 2 + 7.5);
                    } else {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    }
                });

                // Draw enemies
                platforms.forEach(platform => {
                    if (platform.enemy) {
                        ctx.fillStyle = platform.enemy.type === 1 ? 'blue' : 'orange';
                        ctx.fillRect(platform.enemy.x, platform.enemy.y, platform.enemy.width, platform.enemy.height);
                    }
                });

                // // Draw player
                animationProgress = Math.floor(gameFrame / spriteAnimations[currentPlayerState].playerAnimationDelayer) % spriteAnimations[currentPlayerState].data.length;
                ctx.drawImage(currentPlayerState < 4 ? animationImage : animationImageReversed,
                    spriteAnimations[currentPlayerState].data[animationProgress].x,
                    spriteAnimations[currentPlayerState].data[animationProgress].y,
                    spriteAnimations[currentPlayerState].data[animationProgress].width,
                    spriteAnimations[currentPlayerState].data[animationProgress].height,
                    player.x, player.y, player.width, player.height);


                // Draw score
                ctx.fillStyle = 'white';
                ctx.font = '20px Rubik';
                ctx.fillText('Score: ' + score, 10, 30);

                drawSpeakerIcon();


                gameFrame++;
                requestAnimationFrame(updateGame); // Loop
            } else {
                gameOverHandler();
            }
        }
        //------------------------------ 🔺 Game loop 🔺 ------------------------------/

        updateGame();
    </script>
</body>

</html>