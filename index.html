<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game with Screen Scroll</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            -webkit-user-select: none;
            /* Safari */
            -ms-user-select: none;
            /* IE 10 and IE 11 */
            user-select: none;
            /* Standard syntax */
        }

        #gameCanvas {
            background-color: #87CEEB;
        }
    </style>
</head>

<body>
    <audio id="gameAudio" src="icy-remix.mp3"></audio>
    <audio id="gameAudioLower" src="icy-remix-lower-volume.mp3"></audio>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        //----------------------------- 🔻 Constants 🔻 -----------------------------/
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        //----------------------------- 🔺 Constants 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Resize canvas for mobile 🔻 -----------------------------/
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;

            // Regular expressions for mobile User Agent detection
            return /android/i.test(userAgent) || /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
        }

        function resizeCanvas() {
            if (isMobileDevice()) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        //----------------------------- 🔺 Resize canvas for mobile 🔺 -----------------------------/
        /////////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Game settings 🔻 -----------------------------/
        let gravity = 0;
        if (isMobileDevice()) {
            gravity = 1.75;
        } else {
            gravity = 0.48;
        }
        const friction = 0.95;
        const baseJump = -11; // Base jump velocity
        //----------------------------- 🔺 Game settings 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Player 🔻 -----------------------------/
        let player = {
            x: (canvas.width / 2) - 10,
            y: canvas.height - 70,
            width: 20,
            height: 20,
            speed: 50, // horizonal max speed
            velX: 0,
            velY: 0,
            jumping: false,
            onPlatform: true
        };
        //----------------------------- 🔺 Player 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Enemies 🔻 -----------------------------/
        function createEnemy(type, platform) {
            // calculate random x position for the enemy - but make sure it's within the canvas
            let randomEnemyX = platform.x + Math.random() * (platform.width - 20);
            if (randomEnemyX < 0) {
                randomEnemyX = 0;
            } else if (randomEnemyX + 20 > canvas.width) {
                randomEnemyX = canvas.width - 20;
            }
            return {
                type,
                x: randomEnemyX, // Random starting position on the platform
                y: platform.y - 20, // Positioned above the platform
                width: 20,
                height: 20,
                speed: type === 2 ? 1 : 0, // Type 2 enemies move
                direction: 1 // Direction for moving enemies
            };
        }

        function updateEnemyPosition(enemy, platform) {
            if (enemy.type === 2) {
                enemy.x += enemy.speed * enemy.direction;
                // Change direction if enemy reaches the edge of the platform
                if (enemy.x <= Math.max(platform.x, 0) || enemy.x + enemy.width >= Math.min(platform.x + platform.width, canvas.width)) {
                    enemy.direction *= -1;
                }
            }
        }

        function checkPlayerEnemyCollision(player, enemy) {
            return player.x < enemy.x + enemy.width &&
                player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height &&
                player.y + player.height > enemy.y;
        }
        //----------------------------- 🔺 Enemies 🔺 -----------------------------/
        ////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Platforms 🔻 -----------------------------/
        let platforms = [];
        let platformCounter = 0;
        const platformWidthRange = [200, 350];
        const platformHeight = 10;
        let platformGap = 75;

        // Generate random width for the platform
        function randomWidth(platrofmNumber) {
            if (platrofmNumber % 10 == 0) {
                return canvas.width;
            } else {
                return Math.random() * (platformWidthRange[1] - platformWidthRange[0]) + platformWidthRange[0];
            }
        }

        // Generate random x for the platform
        function randomX(platformWidth) {
            // return Math.random() * (canvas.width - (platformWidth - (platformWidth / 2))) - platformWidth / 2;
            if (platformWidth == canvas.width) {
                return 0;
            } else {
                return (Math.random() * canvas.width) - platformWidth / 2;
            }
        }

        // Generate random width AND random x for the platform
        function randomWidthAndX() {
            let width = randomWidth(platformCounter);
            let x = randomX(width);
            return [width, x];
        }
        // Generate the 10 platforms
        for (let i = 0; i < 10; i++) {
            let [tempWidth, tempX] = randomWidthAndX();
            platforms.push({
                x: tempX,
                y: canvas.height - (platformGap * i) - 50,
                width: tempWidth,
                height: platformHeight,
                number: platformCounter,
                playerStandTime: 0, // time in milliseconds the player has been on the platform
                falling: false, // indicates whether the platform is falling
                fallSpeed: 0 // speed at which the platform falls
            });
            if (Math.random() < 0.05 && platformCounter % 10 != 0) {
                const enemyType = Math.random() < 0.5 ? 1 : 2;
                platforms[i].enemy = createEnemy(enemyType, platforms[i]);
            }
            platformCounter++;
        }

        function repositionPlatform(platform, index) {
            if (platform.y > canvas.height) {
                // If platform falls off-screen, reset it
                let [tempWidth, tempX] = randomWidthAndX();
                platform.y = platforms[heighestPlatformIndex].y - platformGap; // Move platform to the top
                platform.x = tempX;
                platform.width = tempWidth;
                platform.number = platformCounter; // Increase platform number
                heighestPlatformIndex = index; // Update the heighest platform index
                platform.playerStandTime = 0;
                platform.falling = false;
                platform.fallSpeed = 0;
                if (Math.random() < 0.05 && platformCounter % 10 != 0) {
                    const enemyType = Math.random() < 0.5 ? 1 : 2;
                    platform.enemy = createEnemy(enemyType, platform);
                } else {
                    platform.enemy = null;
                }
                platformCounter++;
            }
        }
        //----------------------------- 🔺 Platforms 🔺 -----------------------------/
        ///////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Key events 🔻 ------------------------------/
        let keys = [];
        window.addEventListener('keydown', function (e) {
            keys[e.keyCode] = true;
            if (e.keyCode == 32 && !player.jumping && player.onPlatform && !player.velY > 0) { // Space key for jump
                player.jumping = true;
                // player.velY = baseJump - Math.abs(player.velX); // Old "running faster = higher jump" - linear growth
                player.velY = baseJump - Math.pow(Math.abs(player.velX), 2) * 0.2; // New "running faster = higher jump" - exponential growth
                if (!isSpacebarPressedForAudio) {
                    isSpacebarPressedForAudio = true;
                    toggleMute();
                }
            }
        });
        window.addEventListener('keyup', function (e) {
            keys[e.keyCode] = false;
        });
        //------------------------------ 🔺 Key events 🔺 ------------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Touch events for mobile 🔻 ------------------------------/

        // Variables to store touch positions and time
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchX;
        let lastTouchY;
        let lastTouchTime;
        let isSwipeUpDetected = false; // Flag to check if swipe up is already detected

        // Add touch event listeners
        canvas.addEventListener('touchstart', function (e) {
            if (!isSpacebarPressedForAudio) {
                isSpacebarPressedForAudio = true;
                toggleMute();
            }
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            lastTouchX = touchStartX;
            lastTouchY = touchStartY;
            lastTouchTime = Date.now(); // Record the start time
            isSwipeUpDetected = false; // Reset swipe up detection
        }, { passive: false });

        canvas.addEventListener('touchmove', function (e) {
            e.preventDefault();
            let touchMoveX = e.touches[0].clientX;
            let touchMoveY = e.touches[0].clientY;
            let currentTime = Date.now();

            let deltaX = touchMoveX - lastTouchX;
            let deltaTime = currentTime - lastTouchTime;

            // Normalize the swipe speed
            let swipeSensitivity = 2.5; // Adjust for sensitivity
            let maxSwipeSpeed = 50; // Maximum speed per swipe

            if (deltaTime > 0) { // Avoid division by zero
                let swipeSpeed = (deltaX / deltaTime) * swipeSensitivity;
                swipeSpeed = Math.max(Math.min(swipeSpeed, maxSwipeSpeed), -maxSwipeSpeed);
                player.velX += swipeSpeed;
                player.velX = Math.max(Math.min(player.velX, player.speed), -player.speed);
            }

            // Upward swipe detection
            if (!player.jumping && player.onPlatform && lastTouchY - touchMoveY > 10) { // 10 = minimum swipe distance
                player.jumping = true;
                player.velY = baseJump * 1.925 - Math.abs(player.velX) * 0.75;
                isSwipeUpDetected = true;
            }

            lastTouchX = touchMoveX;
            lastTouchY = touchMoveY;
            lastTouchTime = currentTime;
        }, { passive: false });

        canvas.addEventListener('touchend', function (e) {
            e.preventDefault();
            // Reset variables on touch end
            touchStartX = 0;
            touchStartY = 0;
            lastTouchX = 0;
            lastTouchY = 0;
            lastTouchTime = 0;
            player.velX = 0; // Adjust for smoother stopping
            isSwipeUpDetected = false; // Reset swipe up detection
        }, { passive: false });

        //------------------------------ 🔺 Touch events for mobile 🔺 ------------------------------/
        ////////////////////////////////////////////////////////////////////////////////////////
        // ------------------------------ 🔻 Audio & Mute 🔻 ------------------------------/
        let gameAudio = null;
        if (isMobileDevice()) {
            gameAudio = document.getElementById('gameAudioLower');
        } else {
            gameAudio = document.getElementById('gameAudio');
            gameAudio.volume = 0.2;
        }
        let isMuted = true;
        let soundIcon = '▶️';
        let isSpacebarPressedForAudio = false; // For the audio to only start once when spacebar is pressed

        function drawSpeakerIcon() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            ctx.fillText(soundIcon, canvas.width - 30, 30);
        }

        function toggleMute() {
            isMuted = !isMuted;
            if (isMuted) {
                gameAudio.pause();
                soundIcon = '▶️'
            } else {
                gameAudio.play();
                soundIcon = '⏸️';
            }
            drawSpeakerIcon(); // Redraw the speaker icon
        }

        function handleMuteToggle(e) {
            let clientX, clientY;
            if (e.type === 'click') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchstart') {
                // Prevent default behavior to avoid double handling if 'click' event also fires
                e.preventDefault();
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            // Check if the event occurred within the speaker icon bounds
            if (x > canvas.width - 35 && x < canvas.width && y > 0 && y < 40) {
                if (!isSpacebarPressedForAudio) {
                    isSpacebarPressedForAudio = true;
                }
                toggleMute();
            }
        }

        // Listen for click and touchstart events
        canvas.addEventListener('click', handleMuteToggle);
        canvas.addEventListener('touchstart', handleMuteToggle, { passive: false });
        //------------------------------ 🔺 Audio & Mute 🔺 ------------------------------/
        /////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Game over 🔻 ------------------------------/
        let gameOver = false;
        let topTenScores = [];

        function saveScore(score) {
            topTenScores.push(score);
            topTenScores.sort((a, b) => b - a);
            topTenScores = topTenScores.slice(0, 10);
        }

        function displayTopTenScores() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            let TopTenScoresTextMetrics = ctx.measureText('Top 10 Scores:');
            let TopTenScoresTextWidth = TopTenScoresTextMetrics.width;
            ctx.fillText('Top 10 Scores:', canvas.width / 2 - TopTenScoresTextWidth / 2, (canvas.height / 4) + 60);
            for (let i = 0; i < topTenScores.length; i++) {
                let scoreListItemTextMetrics = ctx.measureText(`${topTenScores[i]}`);
                let scoreListItemTextWidth = scoreListItemTextMetrics.width;
                ctx.fillText(`${topTenScores[i]}`, canvas.width / 2 - scoreListItemTextWidth / 2, ((canvas.height / 4) + 60) + ((i + 1) * 30));
            }
        }

        function gameOverHandler() {
            gameAudio.pause(); // Stop the audio
            saveScore(score); // Save the score

            // Clear canvas and display game over message
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'black';
            ctx.font = '50px Rubik';
            const gameOverTextMetrics = ctx.measureText("GAME OVER");
            const gameOverTextWidth = gameOverTextMetrics.width;
            ctx.fillText("GAME OVER", canvas.width / 2 - gameOverTextWidth / 2, canvas.height / 4);

            // Display top 10 scores
            displayTopTenScores();

            // Display play again button above the GAME OVER text
            ctx.fillStyle = 'black';
            ctx.font = '20px Rubik';
            const playAgainTextMetrics = ctx.measureText("Play again!");
            const playAgainTextWidth = playAgainTextMetrics.width;
            ctx.fillText("Play again", canvas.width / 2 - playAgainTextWidth / 2, canvas.height / 8);

        }

        // canvas.addEventListener('click', function (e) {
        //     if (gameOver) {
        //         const rect = canvas.getBoundingClientRect();
        //         const x = e.clientX - rect.left;
        //         const y = e.clientY - rect.top;

        //         // Check if the click occurred within the play again button bounds
        //         if (x > canvas.width / 2 - 50 && x < canvas.width / 2 + 50 && y > canvas.height / 8 - 20 && y < canvas.height / 8) {
        //             resetGame();
        //         }
        //     }
        // });
        function handlePlayAgainInteraction(e) {
            let clientX, clientY;
            if (e.type === 'click') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchstart') {
                e.preventDefault();
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            if (gameOver) {
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                // Check if the interaction occurred within the play again button bounds
                if (x > canvas.width / 2 - 50 && x < canvas.width / 2 + 50 && y > canvas.height / 8 - 20 && y < canvas.height / 8) {
                    resetGame();
                }
            }
        }

        // Listen for click and touchstart events
        canvas.addEventListener('click', handlePlayAgainInteraction);
        canvas.addEventListener('touchstart', handlePlayAgainInteraction, { passive: false });

        //----------------------------- 🔺 Game over 🔺 -----------------------------/
        //////////////////////////////////////////////////////////////////////////////
        //----------------------------- 🔻 Reset game 🔻 -----------------------------/
        function resetGame() {
            gameOver = false;
            player = {
                x: (canvas.width / 2) - 10,
                y: canvas.height - 70,
                width: 20,
                height: 20,
                speed: 50, // horizonal max speed
                velX: 0,
                velY: 0,
                jumping: false,
                onPlatform: true
            };
            platforms = [];
            platformCounter = 0;
            isMuted = true;
            soundIcon = '▶️';
            // isSpacebarPressedForAudio = false;
            heighestPlatformIndex = 9;
            score = 0;
            for (let i = 0; i < 10; i++) {
                let [tempWidth, tempX] = randomWidthAndX();
                platforms.push({
                    x: tempX,
                    y: canvas.height - (platformGap * i) - 50,
                    width: tempWidth,
                    height: platformHeight,
                    number: platformCounter,
                    playerStandTime: 0, // time in milliseconds the player has been on the platform
                    falling: false, // indicates whether the platform is falling
                    fallSpeed: 0 // speed at which the platform falls
                });
                if (Math.random() < 0.05 && platformCounter % 10 != 0) {
                    const enemyType = Math.random() < 0.5 ? 1 : 2;
                    platforms[i].enemy = createEnemy(enemyType, platforms[i]);
                }
                platformCounter++;
            }
            updateGame();
        }
        //----------------------------- 🔺 Reset game 🔺 -----------------------------/
        /////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Loop variables 🔻 ------------------------------/
        let heighestPlatformIndex = 9; // The platform that needs to be generated - should be generated above the heighest platform
        let score = 0;
        //------------------------------ 🔺 Loop variables 🔺 ------------------------------/
        //////////////////////////////////////////////////////////////////////////////////
        //------------------------------ 🔻 Game loop 🔻 ------------------------------/
        function updateGame() {
            if (!gameOver) {
                // Check key inputs
                if (keys[39]) { // right arrow
                    if (player.velX < player.speed) {
                        player.velX += 0.33;
                    }
                }
                if (keys[37]) { // left arrow
                    if (player.velX > -player.speed) {
                        player.velX -= 0.33;
                    }
                }

                // trying the possibility of not stopping the player when left/right key is pressed
                // if (!keys[37] && !keys[39]) {
                //     player.velX *= friction;
                // }

                player.velX *= friction;
                player.velY += gravity;

                player.x += player.velX;
                player.y += player.velY;

                // Screen scroll
                if (player.y < canvas.height / 4) { // player jumped above 1/4 of the canvas
                    player.y += Math.abs(player.velY); // If player is jumping (velocity is negative), cancel the movement by adding absolute value velocity (add positive value)

                    // Go over all platforms and move them down. If needed, move to the top
                    platforms.forEach(function callback(platform, index) {
                        platform.y += Math.abs(player.velY); // Move platforms down with the same amount of positive velocity
                        // if platform has enemy - move the enemy down
                        if (platform.enemy) {
                            platform.enemy.y += Math.abs(player.velY);
                        }
                        repositionPlatform(platform, index);
                    });
                }

                // Collision with the canvas edges
                if (player.x >= canvas.width - player.width) {
                    player.x = canvas.width - player.width;
                } else if (player.x <= 0) {
                    player.x = 0;
                }

                if (player.y >= canvas.height - player.height) {
                    player.y = canvas.height - player.height;
                    player.jumping = false;
                    player.onPlatform = false;
                    player.velY = 0;
                    gameOver = true;
                }

                // Platform collision
                player.onPlatform = false; // reset the flag, so it can be set to true if player is on a platform
                platforms.forEach(function callback(platform, index) {
                    let predictedY = player.y + player.velY;
                    if (
                        player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x &&
                        predictedY + player.height > platform.y &&
                        predictedY + player.height < platform.y + platform.height &&
                        player.y < platform.y + platform.height &&
                        player.velY > 0 // Only when falling
                    ) {
                        player.jumping = false;
                        player.velY = 0;
                        player.y = platform.y - player.height;
                        player.onPlatform = true;

                        if (score < platform.number) { // Update the score
                            score = platform.number;
                        }

                        if (platform.falling === false && platform.number % 10 != 0) {
                            platform.playerStandTime += 1; // Increment platform's stand time

                            if (platform.playerStandTime > 240) {
                                platform.falling = true;
                            }
                        }
                    } else {
                        platform.playerStandTime = 0; // Reset if player is not on platform
                    }
                });

                // Check for player-enemy collisions
                platforms.forEach(platform => {
                    if (platform.enemy) {
                        updateEnemyPosition(platform.enemy, platform);
                        if (checkPlayerEnemyCollision(player, platform.enemy)) {
                            gameOver = true;
                        }
                    }
                });

                // Handle falling platforms
                platforms.forEach(function callback(platform, index) {
                    if (platform.falling) {
                        platform.fallSpeed += gravity; // Increase fall speed by gravity
                        platform.y += platform.fallSpeed; // Apply fall speed
                        // if the platform has enemy - move the enemy down
                        if (platform.enemy) {
                            platform.enemy.y += platform.fallSpeed;
                        }
                    }
                    repositionPlatform(platform, index);
                });

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);


                // Draw platforms
                platforms.forEach(function callback(platform, index) {
                    if (platform.number % 10 == 0) {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height + 5);
                        // draw platforms number inside it
                        ctx.fillStyle = 'black';
                        ctx.font = '16px Rubik';
                        const metrics = ctx.measureText(platform.number);
                        const textWidth = metrics.width;
                        ctx.fillText(platform.number, platform.x + platform.width / 2 - textWidth / 2, platform.y + platform.height / 2 + 7.5);
                    } else {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    }
                });

                // Draw enemies
                platforms.forEach(platform => {
                    if (platform.enemy) {
                        ctx.fillStyle = platform.enemy.type === 1 ? 'blue' : 'orange';
                        ctx.fillRect(platform.enemy.x, platform.enemy.y, platform.enemy.width, platform.enemy.height);
                    }
                });

                // Draw player
                ctx.fillStyle = 'red';
                ctx.fillRect(player.x, player.y, player.width, player.height);

                // Draw score
                ctx.fillStyle = 'white';
                ctx.font = '20px Rubik';
                ctx.fillText('Score: ' + score, 10, 30);

                drawSpeakerIcon();

                // console.log(player.onPlatform);

                requestAnimationFrame(updateGame); // Loop
            } else {
                gameOverHandler();
            }
        }
        //------------------------------ 🔺 Game loop 🔺 ------------------------------/

        updateGame();
    </script>
</body>

</html>